Index: velox/type/Subfield.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/velox/type/Subfield.h b/velox/type/Subfield.h
--- a/velox/type/Subfield.h	(revision 1d12342246b75ccdfd2ac050a0adf27164a8f893)
+++ b/velox/type/Subfield.h	(revision e1f0edb70199de95f84931c8937afc3f65711375)
@@ -40,7 +40,7 @@
 
   bool isSeparator(char c) const {
     return c == closeBracket || c == dot || c == openBracket || c == quote ||
-        c == wildCard;
+        c == wildCard || c == backtick;
   }
 
   char backSlash = '\\';
@@ -50,6 +50,7 @@
   char quote = '\"';
   char wildCard = '*';
   char unicodeCaret = '^';
+  char backtick = '`';
 };
 
 class Subfield {
@@ -121,7 +122,11 @@
     }
 
     std::string toString() const override {
-      return "." + name_;
+      if (name_.find('.') == std::string::npos &&
+          name_.find('\'') == std::string::npos) {
+        return "." + name_;
+      }
+      return ".`" + boost::replace_all_copy(name_, "`", "``") + "`";
     }
 
     bool isSubscript() const override {
Index: velox/type/Tokenizer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/velox/type/Tokenizer.cpp b/velox/type/Tokenizer.cpp
--- a/velox/type/Tokenizer.cpp	(revision 1d12342246b75ccdfd2ac050a0adf27164a8f893)
+++ b/velox/type/Tokenizer.cpp	(revision e1f0edb70199de95f84931c8937afc3f65711375)
@@ -75,7 +75,9 @@
   }
 
   if (firstSegment_) {
-    auto token = matchPathSegment();
+    auto token = tryMatchSeparator(separators_->backtick)
+        ? matchBacktickedPathSegment()
+        : matchPathSegment();
     firstSegment_ = false;
     return token;
   }
@@ -124,6 +126,54 @@
   if (token.empty()) {
     invalidSubfieldPath();
   }
+
+  return std::make_unique<Subfield::NestedField>(token);
+}
+
+std::unique_ptr<Subfield::PathElement> Tokenizer::matchBacktickedPathSegment() {
+  // Backticked path segment allows dot in the segment, e.g., `a.b`.
+  // To escape a backtick in the path segment, using tow consecutive backticks,
+  // e.g., `a.``b```.
+  std::string token;
+
+  bool backtickSeen = false;
+  while (hasNextCharacter()) {
+    const auto peek = peekCharacter();
+    if (peek == separators_->backtick) {
+      // We see a backtick. It could mean one of the following cases:
+      // 1. Tow consecutive backticks: "``", which means an escaped backtick as
+      // part of the path segment.
+      // 2. One single back "`" indicating the end of the backticked path
+      // segment.
+      if (backtickSeen) {
+        // Add a backtick to the path segment.
+        token += separators_->backtick;
+      }
+      backtickSeen = !backtickSeen;
+      // Always consumes the backtick.
+      nextCharacter();
+      continue;
+    }
+    if (backtickSeen) {
+      // End of the backticked path segment.
+      break;
+    }
+    if (!isUnquotedPathCharacter(peek) && peek != separators_->dot) {
+      break;
+    }
+    token += peek;
+    nextCharacter();
+  }
+
+  // The backtick must be enclosed.
+  if (!backtickSeen) {
+    invalidSubfieldPath();
+  }
+
+  // An empty token is not allowed.
+  if (token.empty()) {
+    invalidSubfieldPath();
+  }
 
   return std::make_unique<Subfield::NestedField>(token);
 }
Index: velox/type/Tokenizer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/velox/type/Tokenizer.h b/velox/type/Tokenizer.h
--- a/velox/type/Tokenizer.h	(revision 1d12342246b75ccdfd2ac050a0adf27164a8f893)
+++ b/velox/type/Tokenizer.h	(revision e1f0edb70199de95f84931c8937afc3f65711375)
@@ -68,6 +68,8 @@
 
   std::unique_ptr<Subfield::PathElement> matchPathSegment();
 
+  std::unique_ptr<Subfield::PathElement> matchBacktickedPathSegment();
+
   std::unique_ptr<Subfield::PathElement> matchUnquotedSubscript();
 
   std::unique_ptr<Subfield::PathElement> matchQuotedSubscript();
